{"version":3,"file":"switchboard.js","names":["Actions","isGet","message","switchboardAction","GET","isReply","REPLY","isEmit","EMIT","isError","ERROR","Switchboard","constructor","params","port","name","methods","incrementor","debugMode","isInitialised","init","logError","debug","addEventListener","event","log","data","postMessage","getMethodResult","method","args","executor","messageId","error","result","err","defineMethod","methodName","get","undefined","Promise","resolve","reject","Error","getNewMessageId","listener","removeEventListener","errStr","start","emit","console"],"sources":["../src/switchboard.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport type Params = {\n  port: MessagePort;\n  name?: string;\n  debug?: boolean;\n};\n\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nenum Actions {\n  GET = 'get',\n  REPLY = 'reply',\n  EMIT = 'emit',\n  ERROR = 'error',\n}\n\ntype Method<A extends {}, R> = (args: A) => R | Promise<R>;\n\n// helper types/functions for making sure wires don't get crossed\n\ninterface Message {\n  switchboardAction: Actions;\n}\n\ninterface GetMessage<T = any> extends Message {\n  switchboardAction: Actions.GET;\n  method: string;\n  messageId: string;\n  args: T;\n}\n\nfunction isGet(message: Message): message is GetMessage {\n  return message.switchboardAction === Actions.GET;\n}\n\ninterface ReplyMessage<T = any> extends Message {\n  switchboardAction: Actions.REPLY;\n  messageId: string;\n  result: T;\n}\n\nfunction isReply(message: Message): message is ReplyMessage {\n  return message.switchboardAction === Actions.REPLY;\n}\n\ninterface EmitMessage<T = any> extends Message {\n  switchboardAction: Actions.EMIT;\n  method: string;\n  args: T;\n}\n\nfunction isEmit(message: Message): message is EmitMessage {\n  return message.switchboardAction === Actions.EMIT;\n}\n\ninterface ErrorMessage extends Message {\n  switchboardAction: Actions.ERROR;\n  messageId: string;\n  error: string;\n}\n\nfunction isError(message: Message): message is ErrorMessage {\n  return message.switchboardAction === Actions.ERROR;\n}\n\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport class Switchboard {\n  port: MessagePort;\n\n  name = '';\n\n  methods: Record<string, Method<any, unknown>> = {};\n\n  // used to make unique ids\n  incrementor = 1;\n\n  debugMode: boolean;\n\n  private isInitialised: boolean;\n\n  constructor(params?: Params) {\n    if (!params) {\n      return;\n    }\n    this.init(params);\n  }\n\n  init(params: Params) {\n    if (this.isInitialised) {\n      this.logError('already initialized');\n      return;\n    }\n\n    const { port, name = 'switchboard', debug = false } = params;\n\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n\n    port.addEventListener('message', async event => {\n      this.log('message received', event);\n      const message = event.data;\n      if (isGet(message)) {\n        // find the method, call it, and reply with the result\n        this.port.postMessage(await this.getMethodResult(message));\n      } else if (isEmit(message)) {\n        const { method, args } = message;\n        // Find the method and call it, but no result necessary.\n        // Should this multicast to a set of listeners?\n        // Maybe, but that requires writing a bunch more code\n        // and I haven't found a need for it yet.\n        const executor = this.methods[method];\n        if (executor) {\n          executor(args);\n        }\n      }\n    });\n\n    this.isInitialised = true;\n  }\n\n  private async getMethodResult({\n    messageId,\n    method,\n    args,\n  }: GetMessage): Promise<ReplyMessage | ErrorMessage> {\n    const executor = this.methods[method];\n    if (executor == null) {\n      return <ErrorMessage>{\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" is not defined`,\n      };\n    }\n    try {\n      const result = await executor(args);\n      return <ReplyMessage>{\n        switchboardAction: Actions.REPLY,\n        messageId,\n        result,\n      };\n    } catch (err) {\n      this.logError(err);\n      return <ErrorMessage>{\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" threw an error`,\n      };\n    }\n  }\n\n  /**\n   * Defines a method that can be \"called\" from the other side by sending an event.\n   */\n  defineMethod<A extends {}, R = any>(\n    methodName: string,\n    executor: Method<A, R>,\n  ) {\n    this.methods[methodName] = executor;\n  }\n\n  /**\n   * Calls a method registered on the other side, and returns the result.\n   *\n   * How this is accomplished:\n   * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n   * The other side's switchboard finds a method with that name, and calls it with the arguments.\n   * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n   * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n   *\n   * Instead of an arguments list, arguments are supplied as a map.\n   *\n   * @param method the name of the method to call\n   * @param args arguments that will be supplied. Must be serializable, no functions or other nonsense.\n   * @returns whatever is returned from the method\n   */\n  get<T = unknown>(method: string, args: unknown = undefined): Promise<T> {\n    return new Promise((resolve, reject) => {\n      if (!this.isInitialised) {\n        reject(new Error('Switchboard not initialised'));\n        return;\n      }\n      // In order to \"call a method\" on the other side of the port,\n      // we will send a message with a unique id\n      const messageId = this.getNewMessageId();\n      // attach a new listener to our port, and remove it when we get a response\n      const listener = (event: MessageEvent) => {\n        const message = event.data;\n        if (message.messageId !== messageId) return;\n        this.port.removeEventListener('message', listener);\n        if (isReply(message)) {\n          resolve(message.result);\n        } else {\n          const errStr = isError(message)\n            ? message.error\n            : 'Unexpected response message';\n          reject(new Error(errStr));\n        }\n      };\n      this.port.addEventListener('message', listener);\n      this.port.start();\n      const message: GetMessage = {\n        switchboardAction: Actions.GET,\n        method,\n        messageId,\n        args,\n      };\n      this.port.postMessage(message);\n    });\n  }\n\n  /**\n   * Emit calls a method on the other side just like get does.\n   * But emit doesn't wait for a response, it just sends and forgets.\n   *\n   * @param method\n   * @param args\n   */\n  emit(method: string, args: unknown = undefined) {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    const message: EmitMessage = {\n      switchboardAction: Actions.EMIT,\n      method,\n      args,\n    };\n    this.port.postMessage(message);\n  }\n\n  start() {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    this.port.start();\n  }\n\n  private log(...args: unknown[]) {\n    if (this.debugMode) {\n      console.debug(`[${this.name}]`, ...args);\n    }\n  }\n\n  private logError(...args: unknown[]) {\n    console.error(`[${this.name}]`, ...args);\n  }\n\n  private getNewMessageId() {\n    // eslint-disable-next-line no-plusplus\n    return `m_${this.name}_${this.incrementor++}`;\n  }\n}\n\nexport default new Switchboard();\n"],"mappings":"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","ignoreList":[]}